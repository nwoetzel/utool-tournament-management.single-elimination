package utool.plugin.singleelimination;

import java.util.ArrayList;
import java.util.Random;
import java.util.TimerTask;

import java.util.Timer;

import android.os.Handler;
import android.util.Log;
import utool.plugin.Player;

/**
 * Data class that represents a Single Elimination Tournament
 * 
 * @author hoguet
 *
 * Date: 10-4-2012
 */
public class SingleEliminationTournament extends TournamentLogic{

	/**
	 * The default score given to a player who wins by default (bye round or forfeit)
	 */
	public static final int DEFAULT_DEFAULT_WIN = 2;

	/**
	 * The default round timer setting; no timer
	 */
	public static final int DEFAULT_NO_TIMER = -1; 

	/**
	 * Indicates player confirmed no timer
	 */
	public static final int CONFIRMED_NO_TIMER = -2;

	/**
	 * The score given to a player who wins by default (bye round or forfeit)
	 */
	private int defaultWin;

	/**
	 * The duration of a round in seconds
	 */
	private int roundDuration;

	/**
	 * The round timer
	 */
	private Timer roundTimer;

	/**
	 * The seconds left in the current round
	 */
	private int remainingSeconds;
	/**
	 * The handler to be notified when round timer is updated.  Is passed in when round timer is set
	 */
	private Handler timerHandler;

	/**
	 * Indicates whether or not the timer is paused.
	 */
	private boolean timerPaused = false;

	/**
	 * List of matchups in the tournament
	 */
	private ArrayList<Matchup> matchups;

	/**
	 * Signifies if tournament has started or not
	 */
	private boolean started;

	/**
	 * Signifies if a tournament is finished
	 */
	private boolean finished;

	/**
	 * Is the current round of the tournament
	 */
	private int round;
	
	private ArrayList<OutgoingMessage> outgoingMessageBuffer;



	/**
	 * Constructor
	 * Note: all matchups passed in will have their tournament set to this tournament
	 * 
	 * Since no players list is given,
	 * the players list will be initialized to those found in matchups and can be added/removed after construction
	 * 
	 * @param tournamentId The tournament id all the way from the Core
	 * @param matchups  the initial matchups of the tournament (can be modified but not manually added/removed after creation)
	 */
	protected SingleEliminationTournament(long tournamentId, ArrayList<Matchup> matchups){
		players = new ArrayList<Player>();
		this.tournamentId = tournamentId;  

		if(matchups != null){
			this.matchups = matchups;

			//Look through each matchup and add each player found in the matchups to the tournament's player list.
			for(Matchup m : matchups){
				if(m.getPlayerOne() != null && !players.contains(m.getPlayerOne())&&(!m.getPlayerOne().getUUID().equals(Player.BYE))){
					players.add(m.getPlayerOne());				
				}
				if(m.getPlayerTwo() !=null && !players.contains(m.getPlayerTwo())&&(!m.getPlayerTwo().getUUID().equals(Player.BYE))){
					players.add(m.getPlayerTwo());
				}

				m.setTournament(this);
			}

		}else{
			this.matchups = new ArrayList<Matchup>();
		}

		started = false;
		finished = false;
		round = 0;

		//set round timer to default (no timer) and default win points to default (2)
		roundDuration = DEFAULT_NO_TIMER;
		defaultWin = DEFAULT_DEFAULT_WIN;
		
		outgoingMessageBuffer = new ArrayList<OutgoingMessage>();
	}


	/**
	 * Constructor
	 * Note: all matchups passed in will have their tournament set to this tournament
	 * 
	 * @param tournamentId The tournament id all the way from the Core
	 * @param players the players of the tournament (can be added/removed after construction
	 * @param matchups the initial matchups of the tournament (can be modified but not manually added/removed after creation)
	 */
	protected SingleEliminationTournament(long tournamentId, ArrayList<Player> players, ArrayList<Matchup> matchups){
		this.tournamentId = tournamentId;

		if(players != null){
			this.players = players;
		}else{
			this.players = new ArrayList<Player>();
		}

		if(matchups != null){

			for(Matchup m : matchups){
				m.setTournament(this);
			}               

			this.matchups = matchups;

			//If any players in the matchups are not in the players list, add them now.  Also, setTournament for each matchup
			for(Matchup m : matchups){
				if(m.getPlayerOne() != null && !players.contains(m.getPlayerOne())&&(!m.getPlayerOne().getUUID().equals(Player.BYE))){
					players.add(m.getPlayerOne());                          
				}
				if(m.getPlayerTwo() !=null && !players.contains(m.getPlayerTwo())&&(!m.getPlayerTwo().getUUID().equals(Player.BYE))){
					players.add(m.getPlayerTwo());
				}

				m.setTournament(this);
			}

		}else{
			this.matchups = new ArrayList<Matchup>(); 
		}

		started = false;
		finished = false;
		round = 0;

		//set round timer to default (no timer) and default win points to default (2)
		roundDuration = DEFAULT_NO_TIMER;
		defaultWin = DEFAULT_DEFAULT_WIN;

		outgoingMessageBuffer = new ArrayList<OutgoingMessage>();
	}

	/**
	 * Set the round timer
	 * @param roundDuration duration of round in seconds
	 * @param timerHandler the handler that will be notified when timer updates
	 */
	public void setRoundTimer(int roundDuration, Handler timerHandler){

		//timerHandler must not be null.  if it is, don't do anything
		if(timerHandler != null){

			this.roundDuration = roundDuration;
			this.timerHandler = timerHandler;

			if(roundTimer == null && roundDuration != DEFAULT_NO_TIMER && roundDuration != CONFIRMED_NO_TIMER){
				roundTimer = new Timer();

				//initialize remaining seconds
				remainingSeconds = roundDuration;

			}

		}
	}

	/**
	 * Pauses or unpauses the round timer.
	 * @param paused boolean
	 */
	public void pauseTimer(boolean paused){
		timerPaused = paused;

	}

	/**
	 * Set the points assigned for a default win.
	 * @param defaultWin the points awarded for a default win
	 */
	public void setDefaultWin(int defaultWin){
		this.defaultWin = defaultWin;
	}

	/**
	 * Add player to the tournament.
	 * @param player The player to add
	 */
	public void addPlayer(Player player){

		if(!players.contains(player)&&(!player.getUUID().equals(Player.BYE)))
		{
			players.add(player);
			getStandingsGenerator().addPlayer(player);
			Log.i("SingleEliminationTournament", "added player to Gen");
		}

		//if tournament not started, assign the player to a matchup
		if(!started){			

			ArrayList<Matchup> bottomRound = getBottomRound();
			boolean added = false;

			for(Matchup m : bottomRound){
				if(m.getPlayerOne() == null || m.getPlayerTwo() == null){								
					m.addPlayer(player);
					added = true;
					break; //break so player not added to multiple matchups
				}
			}

			if(!added){ //if not added, means there were no openings in current matchups. new round needs to be added.

				for(Matchup m : bottomRound){

					matchups.add(new Matchup( m.getPlayerOne(), m, this));
					m.removePlayer(m.getPlayerOne());

					matchups.add(new Matchup(m.getPlayerTwo(), m, this));
					m.removePlayer(m.getPlayerTwo());

				}

				//now that new matchups are created, push the request again
				addPlayer(player);

			}

		}

	}



	/**
	 * Removes given player from the tournament.
	 * Removes player from tournament matchups if tournament hasn't started.
	 * If tournament has started, removed player forfeits their current matchup UNLESS opponent is null, in which case nothing happens.
	 * @param p the player to remove
	 */
	public void removePlayer(Player p){

		//		this.players.remove(p);

		//		getStandingsGenerator().removePlayer(p); //TODO this is throwing an exception

		//		ArrayList<Matchup> toRemove = new ArrayList<Matchup>();

		for(Matchup m : matchups){

			if(m.containsPlayer(p)){

				//to fully remove from tournament/standings & replace with bye, matchup must be in first round and scores not set
				if(m.getScores() == null && m.getChildren().isEmpty()){
					m.swapPlayer(p, new Player(Player.BYE, "BYE"));
					players.remove(p);
					getStandingsGenerator().removePlayer(p);

					//if matchup is not finished but is in 2nd or later round, remove from matchup, tournament but not standings
				}else if(m.getWinner() == null){
					m.swapPlayer(p, new Player(Player.BYE, "QUIT")); 
					players.remove(p);
					//purpose of replacing with a BYE is to allow for new player to be added to slot

				}else{
					//do nothing if matchup is finished and in 2nd or later round
				}

			}

		}

		//		for(Matchup m : matchups){
		//
		//			//Only remove player from matchup if tournament not started and scores have not been set.
		//			if(!started && m.getScores() == null){
		//
		//				//Note that m.removePlayer(p) will do nothing and return false if m does not contain p
		//				if(m.removePlayer(p)){
		//
		//					//Check if the removal leaves the matchup null vs. null.
		//					if(m.getPlayerOne() == null && m.getPlayerTwo() == null){
		//						for(Matchup bm : getBottomRound()){
		//							if(bm.getPlayerOne() != null && bm.getPlayerTwo() != null){
		//								m.addPlayer(bm.getPlayerTwo());
		//								bm.removePlayer(bm.getPlayerTwo());
		//								break; //break so that every 2 person matchup isn't removed from
		//							}
		//						}
		//					}
		//
		//					//Check if the removal makes it possible to reduce the number of rounds
		//					int n = 1;
		//					while(n < players.size()){ //if there are 10 players, n will be 16.  if 16, n will be 16.  etc
		//						n *= 2;
		//					}
		//
		//					if(n == players.size()){ //possible to remove a round
		//						for(Matchup bm : getBottomRound()){
		//
		//							if(m.getPlayerOne() != null){
		//								bm.getParent().addPlayer(bm.getPlayerOne());
		//								bm.getParent().removeChild(bm);
		//								toRemove.add(bm);								
		//							}else if(m.getPlayerTwo() != null){
		//								bm.getParent().addPlayer(bm.getPlayerTwo());
		//								bm.getParent().removeChild(bm);
		//								toRemove.add(bm);
		//							}
		//
		//						}
		//					}
		//				}
		//
		//				//If tournament already started, cause removed player to forfeit their current matchup
		//			}else if(m.getScores() == null){				
		//
		//				//If player belongs to the matchup, set winner to their opponent unless opponent is null
		//				if((!m.getPlayerOne().getUUID().equals(Player.BYE))&& m.getPlayerOne().equals(p)){
		//
		//					if((!m.getPlayerTwo().getUUID().equals(Player.BYE)) ){
		//						m.setScores(0, defaultWin); //sets matchup winner to player 2 by forfeiting player 1
		//					}else{
		//						//if player 2 is not known yet, set player 1 forfeit so they will advance once they are known
		//						m.playerOneSetForfeit(true);
		//					}
		//
		//				}else if((!m.getPlayerTwo().getUUID().equals(Player.BYE)) && m.getPlayerTwo().equals(p) && (!m.getPlayerOne().getUUID().equals(Player.BYE))){
		//
		//					if((!m.getPlayerTwo().getUUID().equals(Player.BYE)) ){
		//						m.setScores(defaultWin, 0);
		//					}else{
		//						//if player 1 is not known yet, set player 2 forfeit so they will advance once they are known
		//						m.playerTwoSetForfeit(true);
		//					}
		//				}	
		//			}
		//		}
		//
		//		//Remove any matchups that were supposed to be removed here.  Couldn't be removed above because of concurrent modification Exception
		//		for(Matchup m : toRemove){
		//			matchups.remove(m);  
		//		}

	}




	/**
	 * Sets tournament rounds
	 * @param matchups of the tournament in original state - no winners
	 */
	public void setMatchups(ArrayList<Matchup> matchups){
		this.matchups = matchups;

		for(Matchup m : matchups){

			if(m.getPlayerOne() != null && !this.players.contains(m.getPlayerOne())&&(!m.getPlayerOne().getUUID().equals(Player.BYE))){
				this.players.add(m.getPlayerOne());
			}

			if(m.getPlayerTwo() != null && !this.players.contains(m.getPlayerTwo())&&(!m.getPlayerTwo().getUUID().equals(Player.BYE))){
				this.players.add(m.getPlayerTwo());
			}

		}

	}

	/**
	 * Increments the current round.
	 * TODO consider making private
	 */
	public void advanceRound()
	{
		round++;

		//send out email notifications
		this.getAutomaticEmailHandler().sendOutNotifications();

		//reset round timer
		remainingSeconds = roundDuration;

	}

	/**
	 *	Helper method used to retrieve matchups of specified round.  Used by getBottomRound and getCurrentRound
	 * @param round to retrieve
	 * @return matchups of specified round
	 */
	public ArrayList<Matchup> getRound(int round){

		ArrayList<Matchup> toReturn = new ArrayList<Matchup>();
		
		double doubleRounds = Math.log10(matchups.size()) / Math.log10(2);
		int numRounds;

		//truncate double to int. if not an exact number, add one to ensure enough rounds
		if(doubleRounds % 1 != 0){
			numRounds = (int)doubleRounds;
			numRounds ++;
		}else{
			numRounds = (int)doubleRounds;
		}
		
		//make sure num rounds is at least 1.  if tournament started with 2 players, 0 will result
		if(numRounds == 0){
			numRounds = 1;
		}

		Matchup finalMatchup = null;
		int fCtr = 0;
		while(finalMatchup == null && fCtr < matchups.size()){
			if(matchups.get(fCtr).getParent() == null){
				finalMatchup = matchups.get(fCtr);
			}
			fCtr++;
		}

		ArrayList<Matchup> parents = new ArrayList<Matchup>();
		parents.add(finalMatchup);

		int stopPt = round;
		if(stopPt == 0){
			stopPt = 1;
		}

		//if stopPt is higher than number of rounds, return null
		if(stopPt > numRounds){
			return null;
		}else{

			for(int i = numRounds-1; i >= stopPt; i--){
				ArrayList<Matchup> nextParents = new ArrayList<Matchup>();

				for(Matchup p : parents){

					for(Matchup m : matchups){

						if(m.getParent() != null && m.getParent().equals(p)){
							nextParents.add(m);
						}
					}				
				}

				parents = nextParents;
			}

			toReturn = parents;		

			return toReturn;

		}
	}

	/**
	 * Get matchups of tournament's current round
	 * @return matchups of current round
	 */
	public ArrayList<Matchup> getCurrentRound(){
		return getRound(round);
	}

	/**
	 * Used to retrieve the bottom round (or first round) of the tournament.
	 * @return ArrayList of Matchups in the bottom round
	 */
	public ArrayList<Matchup> getBottomRound(){
		return getRound(1);
	}

	/**
	 * Flags tournament as started and deals with any null matchups that occur due to odd number of players.
	 */
	public void startTournament(){

		if(!started){

			started = true;
			round = 1;			

			//deal with first round nulls; advance the single player
			//TODO stop doing this automatically.
			//			ArrayList<Matchup> bottomRound = getBottomRound();
			//
			//			for(Matchup m : bottomRound){
			//
			//				if(m.getPlayerOne() != null && (m.getPlayerTwo().getUUID().equals(Player.BYE))){
			//
			//					m.setScores(defaultWin, 0);
			//
			//					//					m.getParent().addPlayer(m.getPlayerOne());
			//					//					m.getParent().removeChild(m);
			//					//					matchups.remove(m);
			//				}else if(m.getPlayerTwo() != null && (m.getPlayerOne().getUUID().equals(Player.BYE))){
			//
			//					m.setScores(0, defaultWin);
			//
			//					//					m.getParent().addPlayer(m.getPlayerTwo());
			//					//					m.getParent().removeChild(m);
			//					//					matchups.remove(m);
			//				}
			//
			//			}

			//start round timer
			if(roundTimer != null){
				startRoundTimer();
			}

		}

	}


	/**
	 * Starts the Round timer
	 */
	public void startRoundTimer(){
		if(roundTimer != null){

			roundTimer.scheduleAtFixedRate(new TimerTask(){

				@Override
				public void run() {

					//each second, update the timer displays unless paused
					if(!timerPaused){
						updateTimerDisplays();
					}

				}    			

			}, 0, 1000); //fire each second
		}
	}


	/**
	 * Updates the roundTimerMinutes and roundTimerSeconds variables.
	 */
	private void updateTimerDisplays(){

		//decrement remaining seconds
		if(remainingSeconds > 0){
			remainingSeconds--;
		}

		//in all cases send message to update display
		timerHandler.obtainMessage(1).sendToTarget();
	}

	/**
	 * Used to force creation of new matchup; entails doubling tournament size with empty brackets.
	 * Place given player in one of the new matchups in current round.
	 * @param p
	 */
	public void expandBracket(Player p){

		//determine current number of rounds in tournament
		double doubleRounds = Math.log10(matchups.size()) / Math.log10(2);
		int numRounds;

		//truncate double to int. if not an exact number, add one to ensure enough rounds
		if(doubleRounds % 1 != 0){
			numRounds = (int)doubleRounds;
			numRounds ++;
		}else{
			numRounds = (int)doubleRounds;
		}
		
		if(numRounds == 0){
			numRounds = 1;
		}

		//retrieve final round which only contains one matchup - the final round
		Matchup oldFinal = getRound(numRounds).get(0);

		Matchup newFinal = new Matchup(null, this);
		oldFinal.setParent(newFinal);
		matchups.add(newFinal);

		//if currently in the final round, only one more matchup required
		if(numRounds == round){
			Matchup oldFinalSibling = new Matchup(p, new Player(Player.BYE, "BYE"), newFinal, this);
			matchups.add(oldFinalSibling);
			
		}else{

			Matchup parent = new Matchup(newFinal, this);
			matchups.add(parent);

			ArrayList<Matchup> parents = new ArrayList<Matchup>();
			parents.add(parent);

			//fill in bracket down to the current round.
			for(int i = numRounds-1; i > round; i--){

				ArrayList<Matchup> nextParents = new ArrayList<Matchup>();

				for(Matchup m : parents){
					Matchup childOne = new Matchup(m, this);
					Matchup childTwo = new Matchup(m, this);

					nextParents.add(childOne);
					nextParents.add(childTwo);	
					matchups.add(childOne);
					matchups.add(childTwo);
				}

				parents = nextParents;
			}



			//now fill in extra matchups for current round which will contain the given Player and the rest BYEs
			Matchup firstOne = parents.remove(0);
			matchups.add(new Matchup(p, new Player(Player.BYE, "BYE"), firstOne, this));
			matchups.add(new Matchup(new Player(Player.BYE, "BYE"), new Player(Player.BYE, "BYE"), firstOne, this));

			for(Matchup m : parents){
				matchups.add(new Matchup(new Player(Player.BYE, "BYE"), new Player(Player.BYE, "BYE"), m, this));
				matchups.add(new Matchup(new Player(Player.BYE, "BYE"), new Player(Player.BYE, "BYE"), m, this));
			}

		}

	}

	/**
	 * Used to randomly create matchups from a list of players
	 * If number of players != a power of 2 (8, 16, 32, etc), some players will not have an opponent in first round.
	 * 
	 * @param players the list of players to put into matchups 
	 * @param tournament the tournament the matchups should be assigned to.  It's ok for this to be null
	 * @return arraylist of Matchups made from the players given.
	 */
	public  static ArrayList<Matchup> generateRandomMatchups(ArrayList<Player> players, SingleEliminationTournament tournament){

		if(players != null){


			ArrayList<Matchup> matchups = new ArrayList<Matchup>();	

			//N is the number of players that matchups are created for.  May be different than actual number of players.
			int n = 1;
			while(n < players.size()){ //if there are 10 players, n will be 16.  if 16, n will be 16.  etc
				n *= 2;
			}

			Matchup finalRound = new Matchup(null, tournament); // no parent matchup
			matchups.add(finalRound);

			//handle 0, 1, 2 player cases, which means no additional matchups are created
			if(players.size() <= 2){

				//add the 0, 1, or 2 players to the only matchup of tournament
				for(Player p : players){
					finalRound.addPlayer(p);
				}

			}else{

				int roundSize = 2; //starts at second last round where there will be 2 matchups (semi finals)
				ArrayList<Matchup> parents = new ArrayList<Matchup>();
				parents.add(finalRound);

				ArrayList<Matchup> bottomRound = new ArrayList<Matchup>();

				while(roundSize <= n/2){

					if(roundSize != n/2){

						//start building next round's parents
						ArrayList<Matchup> nextParents = new ArrayList<Matchup>();

						//expect parents to have size == roundSize/2			
						for(int i = 0; i < roundSize/2; i++){ 

							Matchup left = new Matchup(parents.get(i), tournament);
							Matchup right = new Matchup(parents.get(i), tournament);

							nextParents.add(left);
							nextParents.add(right);

							matchups.add(left);
							matchups.add(right);			

						}

						parents = nextParents;	

					}else{ //bottom round so save the matchups in separate list

						for(int i = 0; i < roundSize/2; i++){

							Matchup left = new Matchup(parents.get(i), tournament);
							Matchup right = new Matchup(parents.get(i), tournament);

							bottomRound.add(left);
							bottomRound.add(right);

						}
					}

					roundSize *=2;
				}


				ArrayList<Player> playersSafeToRemoveFrom = new ArrayList<Player>();
				for(Player p : players){
					playersSafeToRemoveFrom.add(p);
				}

				//assign players to bottom round of tournament randomly.  
				//if players do not fit evenly into brackets, some will be assigned no opponent and should automatically win round
				Random r = new Random();		
				while(playersSafeToRemoveFrom.size() > 0)
				{
					//in essence this will execute twice. First time will add first player to all matchups, second time will add player to first n matchups
					//where n is the number of matchups without a Bye
					for(Matchup m : bottomRound)
					{
						//for each matchup, remove up to one player from playersSafeToRemoveFrom and add to the matchup
						if(playersSafeToRemoveFrom.size() > 1)
						{
							//if playersToRemoveFrom has more than one left, remove one at random and add to the matchup
							m.addPlayer(playersSafeToRemoveFrom.remove(r.nextInt(playersSafeToRemoveFrom.size()-1)));
						}
						else if(playersSafeToRemoveFrom.size() == 1)
						{
							//if there is only one player left, add it to the matchup
							m.addPlayer(playersSafeToRemoveFrom.remove(0));
						}
						else
						{
							//no players left in matchup, therfore start add a BYE to the matchup
							m.addPlayer(new Player(Player.BYE,"BYE"));
						}
					}

				}

				//add matchups of bottom round to matchups
				for(Matchup m : bottomRound){
					matchups.add(m);
				}

			}

			return matchups;
		}else{
			return null;
		}

	}

	/**
	 * Checks validity of matches (valid matchups = no duplicate players).
	 * Should only be used for matchups for one round.  Will NOT work for full list of matchups for a tournament.
	 * @param matchups The matchups  (of one round) to check
	 * @return true if there are no duplicate players in matchups.  false if there are
	 */
	public static boolean validateMatchups(ArrayList<Matchup> matchups){

		//problem if matchups for more than one round.  will be returning false if there 2+ rounds of matchups b/c player (validly) belongs to more than 1 matchup
		ArrayList<Player> playersInMatchups = new ArrayList<Player>();

		for(Matchup m : matchups){
			int nullCount = 0;

			//Check if player one is non-null duplicate
			if(m.getPlayerOne() != null && !playersInMatchups.contains(m.getPlayerOne())){
				playersInMatchups.add(m.getPlayerOne());
			}else if(m.getPlayerOne() != null){
				return false;
			}else{
				nullCount++;
			}

			//Check if player 2 is non-null duplicate
			if(m.getPlayerTwo() != null && !playersInMatchups.contains(m.getPlayerTwo())){
				playersInMatchups.add(m.getPlayerTwo());
			}else if(m.getPlayerTwo() != null){
				return false;
			}else{
				nullCount++;
			}

			//Check for null vs null match ups
			if(nullCount == 2){
				return false;
			}
		}

		return true;

	}


	/**
	 * @return ArrayList of Matchups in the tournament
	 */
	public ArrayList<Matchup> getMatchups(){
		return matchups;
	}

	/**
	 * @return true if tournament is started
	 */
	public boolean isStarted(){
		return started;
	}

	/**
	 * 	@return current round of tournament.  0 if not started
	 */
	public int getRound(){
		return round;
	}

	/**
	 * @return round duration in second
	 */
	public int getRoundDuration(){
		return roundDuration;
	}

	/**
	 * @return minutes remaining in current round
	 */
	public int getMinutes(){		
		int roundTimerSeconds = remainingSeconds % 60;
		int roundTimerMinutes = (remainingSeconds - roundTimerSeconds) / 60;

		return roundTimerMinutes;
	}

	/**
	 * @return seconds (0-59) remaining in current round
	 */
	public int getSeconds(){
		return remainingSeconds % 60;
	}

	/**
	 * @return points awarded in case of default win
	 */
	public int getDefaultWin(){
		return defaultWin;
	}

	/**
	 * End the tournament
	 */
	public void endTournament(){
		finished = true;

		//stop timer
		if(roundTimer != null){
			roundTimer.cancel();
		}
	}

	/**
	 * Get whether the tournament has ended
	 * @return True if ended
	 */
	public boolean isFinished(){
		return finished;
	}
	
	public void addMessageToBuffer(OutgoingMessage m){
		outgoingMessageBuffer.add(m);
	}
	
	public OutgoingMessage getNextMessageFromBuffer(){
		if(outgoingMessageBuffer.isEmpty()){
			return null;
		}else{
			return outgoingMessageBuffer.remove(0);
		}
	}
	
	public ArrayList<OutgoingMessage> getOutgoingMessageBuffer(){
		return outgoingMessageBuffer;
	}


}
