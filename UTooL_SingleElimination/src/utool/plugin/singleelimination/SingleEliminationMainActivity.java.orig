package utool.plugin.singleelimination;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import utool.plugin.IUTooLCore;
import utool.plugin.Player;
import utool.plugin.singleelimination.communications.CoreSEBridge;
import utool.plugin.singleelimination.communications.IncomingCommandHandlerHost;
import utool.plugin.singleelimination.communications.IncomingCommandHandlerParticipant;
import utool.plugin.singleelimination.communications.OutgoingCommandHandler;
import utool.plugin.singleelimination.communications.SaxFeedParser;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.app.Activity;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

/**
 * This activity is the primary entry point for the Single Elimination plugin.
 * It should only be invoked by the UTooL Core application, and depends on it to run properly.
 * @author Cory Bryan
 *
 */
public class SingleEliminationMainActivity extends Activity {
	/**
	 * String used for core service discovery
	 * @since 10/4/2012
	 */
	static final String UTOOL_SERVICE_NAME = "utool.core.UTooLCoreService";

	/**
	 * Tag used for logging
	 * @since 10/4/2012
	 */
	private static final String LOG_TAG = "utool.plugin.SingleEliminationMainActivity";

	/**
	 * Holds the list of players
	 */
	public static List<Player> playerList;

	/**
	 * Holds the tournament id of the running SE tournament
	 */
	public static long tournamentId;

	/**
	 * Holds whether or not the user of the SE plugin is the host of the tournament or not.
	 * Used to determine permissions in the Commandhandlers
	 */
	public static boolean isHost = false;

	/**
	 * Hold the name of the tournament if one has been set
	 */
	public static String tournamentName;


	/**
	 * Used to display toasts to the screen
	 */
	private SingleEliminationMainActivity activity = this;

	/**
	 * the player id of the user on this device
	 */
	public static UUID pid = new UUID(-1,-1);

	/**
	 * Runnable used by thread to receive messages
	 */
	Runnable receiveRunnable = new Runnable() 
	{
		public void run() 
		{
			try {
				while (true)
				{
					String msg = mICore.receive();
					if (msg.equals("-1")){
						return;
					}
					//determine which IncomingCOmmandHandler to attach to this plugin//TODO
					SaxFeedParser s;
					if(isHost)
					{
						s = new SaxFeedParser(new IncomingCommandHandlerHost());
					}
					else
					{
						s = new SaxFeedParser(new IncomingCommandHandlerParticipant());

					}
					s.parse(msg);
				}
			} catch (RemoteException e) {
				e.printStackTrace();
			}
		}
	};




	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		//Enable debugging for this plugin
	//	android.os.Debug.waitForDebugger();


		//Get parameters through intent
		if(getIntent().getExtras()!=null)
		{
			tournamentId = getIntent().getExtras().getLong("tournamentId");
			tournamentName = getIntent().getExtras().getString("tournamentName");
			playerList = getIntent().getExtras().getParcelableArrayList("playerList");
			isHost = getIntent().getExtras().getBoolean("isHost",false);
			pid = UUID.fromString(getIntent().getExtras().getString("pid"));
			StandingsGeneratorSE.clearInstance();
			Log.d(LOG_TAG, "List: "+playerList);

		}
		else
		{
			//instantiate player list
			playerList = new ArrayList<Player>();
			isHost=false;
			//TODO probably should error to user and close plugin
		}

		//set tournament name
		if(tournamentName==null)
		{
			tournamentName  = "SE: "+tournamentId;
		}

		//set tournament name
		((TextView)findViewById(R.id.tournament_name)).setText("Name: "+tournamentName);

		


		//Connect to the plugin core service
		Intent serviceBindIntent = new Intent(UTOOL_SERVICE_NAME);
		serviceBindIntent.putExtra("tournamentId", tournamentId);
		bindService(serviceBindIntent, mConnection, Context.BIND_AUTO_CREATE);
		//Service connection is async, so we can't actually use it quite yet. Look in mConnection.onServiceConnected

		Button btnOne = (Button) findViewById(R.id.button1);
		btnOne.setOnClickListener(new View.OnClickListener() {

			public void onClick(View arg0) {
				Intent i = new Intent(SingleEliminationMainActivity.this, MatchupsActivity.class);
				startActivity(i);
			}
		});

		//add ability to transition to standings
		Button standings = (Button) findViewById(R.id.viewStandings);
		standings.setOnClickListener(new View.OnClickListener() {

			public void onClick(View arg0) {
				Intent i = new Intent(SingleEliminationMainActivity.this, SingleEliminationStandingsActivity.class);
				startActivity(i);
			}
		});

		//register as the main activity for the bridge class
		CoreSEBridge.getInstance().setMainActivity(this);
	}

	@Override
	public void onDestroy(){
		super.onDestroy();

		//This activity is being destroyed, so disconnect from the service
		unbindService(mConnection);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	/**
	 * Checks if the plugin was told to close from the single elimination standings activity, and
	 * finishes if the plugin is exiting
	 * @author Justin Kreier
	 * @since 10/11/2012
	 */
	@Override
	protected void onResume(){
		super.onResume();

		//update name field
		((TextView)findViewById(R.id.tournament_name)).setText("Name: "+tournamentName);

		if(SingleEliminationStandingsActivity.isPluginClosing){
			Log.d("SingleEliminationMainActivity", "Closing plugin");
			SingleEliminationStandingsActivity.isPluginClosing = false;
			finish();
		}
	}

	/**
	 * The reference to the UTooLCore Service instance for this plugin
	 * @since 10/4/2012
	 */
	private IUTooLCore mICore;

	/**
	 * The connection to the UTooLCore Service instance for this plugin
	 * @since 10/4/2012
	 */
	private ServiceConnection mConnection = new ServiceConnection() 
	{
		//Called when the connection with the service is established
		public void onServiceConnected(ComponentName className, IBinder service) {
			//This gets an instance of the IUTooLCore interface, which we can use to call on the service
			mICore = IUTooLCore.Stub.asInterface(service);

			//Now we can use the service
			//Code to run when service is connected
			try {
				if (mICore.isClient()){

				} else {

				}

				//create thread to get received messages
				Thread t  = new Thread(receiveRunnable);
				t.start();
				
				//send tournament name
				OutgoingCommandHandler.handleSendTournamentName(SingleEliminationMainActivity.tournamentId, SingleEliminationMainActivity.tournamentName);
				((TextView)findViewById(R.id.tournament_name)).setText("Name: "+tournamentName);
				
				//send players to playerlist
				StandingsGeneratorSE.getInstance(playerList);

			} catch (RemoteException e) {
				Log.e(LOG_TAG, e.toString());
				Toast t = new Toast(SingleEliminationMainActivity.this);
				t.setText("Error connecting to core service");
				t.show();
			}
		}

		//Called when the connection with the service disconnects unexpectedly
		public void onServiceDisconnected(ComponentName className) {
			Log.e(LOG_TAG, "Service has unexpectedly disconnected");
			mICore = null;
		}
	};


	/**
	 * This is to be called when there is a message to send to the core
	 * @param s the message in xml format to send
	 * @return true if sent
	 */
	public boolean sendMessage(String s)
	{
		try 
		{
			mICore.send(s);
			return true;
		} catch (RemoteException e) 
		{
			e.printStackTrace();
			return false;
		}
	}

	/**
	 * used for displaying toasts to the screen
	 */
	private String message="";

	/**
	 * This method is to be called when a message received from the server is to be displayed
	 * via a toast to the screen
	 * @param s String to display to the screen
	 */
	public void displayMessage(String s) 
	{
		message = s;
		this.runOnUiThread(new Runnable() {
			public void run() {
				Toast.makeText(activity, "Msg: "+message, Toast.LENGTH_LONG).show();
			}
		});

	}


}
